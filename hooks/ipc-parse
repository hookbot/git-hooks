#!/usr/bin/perl

use warnings;
use strict;

sub crash {
    my $err_message = shift;
    my $out_message = shift // "{}";
    $out_message =~ s/\s*$/\n/;
    print $out_message;
    defined($err_message) or exit 1;
    $err_message =~ s/\s*$//;
    die "$0: $err_message\n";
}

my $ipc = $ENV{IPC} || shift or crash "Not invoked properly from git hooks.";

open my $fh, "<", "$ipc/log.trace" or crash "$ipc/log.trace: Unable to read IPC info file? $!";
my $log = join "", <$fh>;
close $fh;

if ($log =~ s/[\s\S]*?^(.*?execve.*git-shell.* = 0)//m) {
    my $launch = $1;
    $ENV{SSH_ORIGINAL_COMMAND} ||= $1 if $launch =~ s/.*?execve.*\[.*git-shell.*?"-c",\s*"([^\"]+)".*?\],\s*//;
    while ($launch =~ s/\["([^=\"]+)=([^\"]*)",?\s?/\[/) {
        my $key = $1;
        my $val = $2;
        $ENV{$key} ||= $val;
    }
}

my $ssh = $ENV{SSH_CONNECTION} or crash "Only SSH supported";
my $KEY = $ENV{KEY} || "UNKNOWN";
my ($ip, $remote_port, $local_ip, $local_port) = split /\ +/, $ssh;
my $cmd = $ENV{SSH_ORIGINAL_COMMAND} or crash "Unable to determine SSH command";
my $operation = "";
if ($cmd =~ /^git-receive-pack\s/) {
    $operation = "push";
}
elsif ($cmd =~ /^git-upload-pack\s/) {
    $operation = "pull";
}
die "Unrecognized invocation [$cmd]\n" unless $operation;

my $xmods = $ENV{XMODIFIERS} || "";
my $xdebug = 0;
if ($xmods =~ /\bDEBUG\s*=\s*([^,]*)/i) {
    my $debug = $1;
    if ($debug !~ /^(?:|0|off|false)$/i) {
        $xdebug = $debug =~ /^(\d+)$/ ? $1 : 1;
    }
}

my $client_to_server = "";
my $server_to_client = "";
my $stderr = "";
while ($log =~ s/^[\s\d:\.\-]+?(read|write)\(([012]),\s*(.+)//m) {
    my $op = $1;
    my $fd = $2;
    my $s = $3;
    $s = $1 if $s =~ /"(.*)"/;
    $s =~ s/\\([0-7]{1,3})/eval "0$1"/eg;
    $s =~ s/\\x([0-9a-f]{2})/eval "chr 0x$1"/eg;
    $s =~ s/\\t/\t/g;
    $s =~ s/\\r/\r/g;
    $s =~ s/\\n/\n/g;
    $s =~ s/\\\\/\\/g;
    if ($op eq "read" and $fd eq "0") {
        $client_to_server .= $s;
    }
    elsif ($op eq "write" and $fd eq "1") {
        $server_to_client .= $s;
    }
    elsif ($op eq "write" and $fd eq "2") {
        $stderr .= $s;
    }
}
my $extracted = "";
while ($client_to_server =~ s/^([0-9a-f]{4})//) {
    my $packet_len = -4 + hex $1;
    if ($packet_len > 0) {
        $extracted .= substr($client_to_server, 0, $packet_len, "");
        $extracted =~ s/\s*$/\n/;
    }
}
$client_to_server = $extracted;
$extracted = "";
while ($server_to_client =~ s/^([0-9a-f]{4})//) {
    my $packet_len = -4 + hex $1;
    if ($packet_len > 0) {
        $extracted .= substr($server_to_client, 0, $packet_len, "");
        $extracted =~ s/\s*$/\n/;
    }
}
$server_to_client = $extracted;
#warn "DEBUG: leftovers=[$log]\n";
warn "DEBUG: in=[$client_to_server]\n";
warn "DEBUG: out=[$server_to_client]\n";
warn "DEBUG: err=[$stderr]\n";

my $info = {};

$info->{xmodifiers} = $xmods if $xmods;
$info->{xdebug} = $xdebug if $xdebug;

if ($ENV{USER} and $ENV{HOME} and $ENV{GIT_DIR} and my $full = $ENV{GIT_DIR}) {
    $full =~ s{^\Q$ENV{HOME}\E/*}{};
    $full ||= ".";
    $full =~ s/\.git$//;
    $info->{repo} = "ssh://$ENV{USER}\@[$local_ip]/$full";
}

$info->{key} = $KEY;
$info->{client_ip} = $ip;
$info->{client_port} = $remote_port;
$info->{server_ip} = $local_ip;
$info->{server_port} = $local_port;

# Guess client operation based on command they sent
$info->{operation} = $operation;

my $have = [];
while ($client_to_server =~ s/\bhave ([0-9a-f]{32,40})\b//) {
    push @$have, $1;
}
my $want = [];
while ($client_to_server =~ s/\bwant ([0-9a-f]{32,40})\b//) {
    push @$want, $1;
}
if ($operation eq "pull" and @$want and !@$have) {
    $info->{operation} = "clone";
}

# Example: agent=git/2.39.3.(Apple.Git-146)
$info->{client_git_version} = $1 if $client_to_server =~ m{ agent=([\w/\.\ \-\(\)]+)};
$info->{server_git_version} = $1 if $server_to_client =~ m{ agent=([\w/\.\ \-\(\)]+)};

$info->{error_code} = $ENV{GIT_PRE_EXIT_STATUS} || $ENV{GIT_EXIT_STATUS} // -1;
$info->{success} = $info->{error_code} ? 0 : 1;

if ($info->{success}) {
    my $refs = [];
    if ($operation eq "push") {
        # Did the client PUSH anything?
        # Sniff out tags and branches from pushinfo.log
        if (open my $fh, "<", "$ipc/pushinfo.log") {
            my $ref = {};
            while (<$fh>) {
                if (/^(\s*)(\w+):\s*(.*)/) {
                    if (!length $1) {
                        push @$refs, $ref if keys %$ref;
                        $ref = {};
                    }
                    $ref->{lc $2} = $3;
                }
                else {
                    s/\s*$//;
                    warn "pushinfo.log: corrupted=[$_]\n";
                }
            }
            close $fh;
            push @$refs, $ref if keys %$ref;
        }
        else {
            warn "pushinfo.log: MISSING? $!\n";
        }
    }
    else {
        # Did the client PULL anything?
        # Sniff out tags and branches from @$want
        my $want_ref_hash = {};
        foreach my $hash (@$want) {
            # Security Emergency Taint Sniffing
            if ($hash =~ /^(\w+)$/) {
                $hash = $1;
                foreach my $refname (`git branch --format '%(refname)' --contains $hash ; git tag --format '%(refname)' --contains $hash`) {
                    chomp $refname;
                    $want_ref_hash->{$refname}->{$hash} = 1;
                }
            }
        }
        my $have_ref_hash = {};
        foreach my $hash (@$have) {
            # Security Emergency Taint Sniffing
            if ($hash =~ /^(\w+)$/) {
                $hash = $1;
                foreach my $refname (`git branch --format '%(refname)' --contains $hash ; git tag --format '%(refname)' --contains $hash`) {
                    chomp $refname;
                    $have_ref_hash->{$refname}->{$hash} = 1;
                }
            }
        }
        foreach my $refname (keys %$want_ref_hash) {
            my $hashes = [ keys %{ $want_ref_hash->{$refname} } ];
            my $type = $refname =~ s/^refs\/tags\/// ? "tag" :
                $refname =~ s/^refs\/heads\/// ? "branch" : "";
            if ($type) {
                foreach my $hash (@$hashes) {
                    # XXX: Do we need to look in @$have to compute the "old" hash?
                    push @$refs, {
                        ref => $refname,
                        type => $type,
                        new => $hash,
                    };
                }
            }
        }
    }
    $info->{refs} = $refs;
}

if (eval { require JSON }) {
    print JSON::to_json($info)."\n";
}
elsif (eval { require Data::Dumper }) {
    print Data::Dumper::Dumper($info);
}
else {
    print qq{{"error":"Data Transport Failure"}\n};
}
exit;
