#!/usr/bin/env perl

=pod

=head1 NAME

git-server - Secure Git Server with more granular hooks capabilities than default git.

=head1 SYNOPSIS

  Standard Method:
  With SHELL=/bin/bash, use the following format in ~/.ssh/authorized_keys:
  command="~/git-server/gitserver KEY=USER1" ssh-rsa AAAA___blah_pub__ user1@workstation

   -- OR --

  Advanced Method:
  Set SHELL=/path/to/git-server (in /etc/passwd) and
  Set "PermitUserEnvironment yes" (in /etc/ssh/sshd_config)
  Then use the following format in ~/.ssh/authorized_keys:
  environment="KEY=USER1" ssh-rsa AAAA___blah_pub__ user1@workstation

=head1 ENV

You can set as many %ENV variables as you want
within the authorized_keys configuration.

=head1 INSTALL

This can be used with any existing git repositories or as a drop-in replacement
for git-shell or you can create a fresh repo on the git host:

  git init --bare project

Then add whatever hooks you want:

  vi project/.git/hooks/pre-read

Each hook can read the ENV settings defined in authorized_keys.

See contrib/* or hooks/* for some working "hooks" examples.

=head1 HOOKS

All the normal git hooks will continue to work, plus the following:

=head2 hooks/pre-read

Executed before any repository read operation,
such as "git clone" or "git pull" or "git fetch".
The Environment variable GIT_PRE_EXIT_STATUS will
be set to the exit status of this pre-read.
If this exit status is exactly zero, then the
git read operation will be executed.
Otherwise, the git read operation will be aborted.

=head2 hooks/post-read

If the Environment variable GIT_PRE_EXIT_STATUS is defined,
then post-read will know that the pre-read ran,
and its exit status will be available in this variable.
If it does not exist, then pre-read never ran.
If the Environment variable GIT_EXIT_STATUS is defined,
then post-read will know that the git operation ran,
and its exit status will be this variable.
If it does not exist, then the git operation never ran.

This post-read hook will always be executed regardless
of the exit statuses of pre-read or the git operation.
The post-read hook cannot be used to block the git operation
since it's already completed, thus the exit status is ignored.

=head2 hooks/pre-write

Executed before any repository modification attempt,
such as "git push".
Unlike the hooks/update hook, this hooks/pre-write
will always be triggered for write operations, even
if there are no actual changes that need to be made.
The Environment variable GIT_PRE_EXIT_STATUS will
be set to the exit status of this pre-write.
If this exit status is exactly zero, then the
git write operation will be executed.
Otherwise, the git write operation will be aborted.

=head2 hooks/post-write

If the Environment variable GIT_PRE_EXIT_STATUS is defined,
then post-write will know that the pre-write ran,
and its exit status will be available in this variable.
If it does not exist, then pre-write never ran.
If the Environment variable GIT_EXIT_STATUS is defined,
then post-write will know that the git operation ran,
and its exit status will be this variable.
If it does not exist, then the git operation never ran.

This post-write hook will always be executed regardless
of the exit statuses of pre-write or the git operation.
The post-write hook cannot be used to block the git operation
since it's already completed, thus the exit status is ignored.

=head2 hooks/git-shell

If this exists, then it will be executed instead of
the real git-shell program.

=head1 SEE ALSO

Similar functionality to the following:

  gitlab-shell, gitolite, git-shell

=head1 AUTHOR

Rob Brown <bbb@cpan.org>

=head1 COPYRIGHT AND LICENSE

Copyright 2015-2024 by Rob Brown <bbb@cpan.org>

This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut

use strict;
use warnings;
use Cwd qw(abs_path);

our $VERSION = "0.018";

my $ssh = $ENV{SSH_CLIENT} or die "Only SSH allowed\n";

my $git_op_hook = {
    "git-upload-pack" => "read", # i.e., clone, pull, fetch
    "git-receive-pack" => "write", # i.e., push
};

$SIG{PIPE} = sub { exit 1; };

my $cmd = undef;
if (@ARGV == 2 and $ARGV[0] eq "-c") {
    # Advanced Method:
    shift; # -c
    $cmd = shift; # i.e., "git-upload-pack 'project'"
}
else {
    # Standard Method:
    if (my $o = delete $ENV{SSH_ORIGINAL_COMMAND}) {
        $cmd = $o;
    }
    foreach my $pair (@ARGV) {
        if ($pair =~ /^(\w+)=(.*)$/) {
            $ENV{$1} = $2;
        }
        else {
            die "Invalid ENV setting [$pair]\n";
        }
    }
}

my $KEY = $ENV{KEY} || "UNKNOWN";
my $ip = $ssh =~ /^([\da-f\.:]+) /i ? $1 : "UNKNOWN";
die localtime().": [$KEY\@$ip] git-server: You don't have shell access!\n" unless $cmd;
warn localtime().": [$KEY\@$ip] git-server: Detected XMODIFIERS [$ENV{XMODIFIERS}]\n" if $ENV{XMODIFIERS};

my $dir = undef;
my $hook = undef;
if ($cmd =~ /^(git-[\w\-]+) (.+)$/) {
    my $op = $1;
    my $repo = $2;
    $hook = $git_op_hook->{$op} or die localtime().": [$KEY\@$ip] git-server: Unimplemented operation! $op\n";
    $repo = $1 if $repo =~ /^'(.+)'$/;
    $repo =~ s/\.git$//;
    my $home = $ENV{HOME} || (getpwuid $<)[7];
    foreach my $try ("$repo.git/.git", "$repo/.git", "$repo.git", $repo) {
        if (-d $try) {
            $dir = $try;
            $ENV{GIT_DIR} = abs_path $dir;
            last;
        }
        if ($try =~ s{^/+}{} and -d $try) {
            $dir = $try;
            $ENV{GIT_DIR} = abs_path $dir;
            last;
        }
        if ($try =~ s{^~/}{$home/} and -d $try) {
            $dir = $try;
            $ENV{GIT_DIR} = abs_path $dir;
            last;
        }
    }
    die localtime().": [$KEY\@$ip] git-server: You can't access '$repo' git repository\n" unless $dir;
    $cmd = "$op '$ENV{GIT_DIR}'";
}
else {
    die localtime().": [$KEY\@$ip] git-server: You can't run the command '$cmd'\n";
}

# Custom hooks are free to read or write in this IPC folder
my $tmpdir = "$ENV{GIT_DIR}/tmp";
mkdir $tmpdir, 0700 unless -d $tmpdir;
$ENV{IPC} = "$tmpdir/current-$hook-$$-io";
mkdir $ENV{IPC}, 0700;
die localtime().": [$KEY\@$ip] git-server: Unable to create [$ENV{IPC}] folder! $!\n" unless -d $ENV{IPC};

my $pre_failure = 0;
if (-x "$dir/hooks/pre-$hook") {
    if ($pre_failure = spawn($dir, "hooks/pre-$hook")) {
        warn "pre-$hook: failed! $pre_failure\n";
    }
    $ENV{GIT_PRE_EXIT_STATUS} = $pre_failure;
}

my $git_failure = $pre_failure;
if (!$pre_failure) {
    my $shell = "$dir/hooks/git-shell";
    $shell = "git-shell" unless -x $shell;
    $git_failure = spawn(".", $shell, "-c", $cmd);
    $ENV{GIT_EXIT_STATUS} = $git_failure;
}

my $post_failure = 0;
if (-x "$dir/hooks/post-$hook") {
    if ($post_failure = spawn($dir, "hooks/post-$hook")) {
        warn "post-$hook: failed! $post_failure\n";
    }
}

# Wipe out anything in the IPC folder
system "rm -rfv $ENV{IPC}*" if $ENV{IPC};
#unlink glob "$ENV{IPC}/*"; rmdir $ENV{IPC};
rmdir $tmpdir; # Only clear if empty

exit $git_failure;

# spawn( $chdir, $cmd, [ @args ] )
# chdir $chdir
# before running cmd.
# Returns the exit status
sub spawn {
    my $chdir = shift;
    my @cmd = @_;
    my $pid = fork;
    if ($pid) {
        # Parent
        waitpid($pid, 0);
        return $? & 127 || $? >> 8;
    }
    elsif (!defined $pid) {
        die "fork: $!\n";
    }
    else {
        # Child
        chdir($chdir) or die "$chdir: chdir: $!\n";
        exec @cmd or die "From($chdir) $cmd[0]: exec: $!";
    }
}
